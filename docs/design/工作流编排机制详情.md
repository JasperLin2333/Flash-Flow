# ğŸ”„ å·¥ä½œæµç¼–æ’æœºåˆ¶è¯¦æƒ…

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° Flash Flow å·¥ä½œæµçš„åº•å±‚ç¼–æ’æœºåˆ¶ï¼ŒåŒ…æ‹¬ä¸Šä¸‹æ–‡ç®¡ç†ã€å˜é‡ç³»ç»Ÿã€æ‰§è¡Œå¼•æ“ã€åˆ†æ”¯æ§åˆ¶å’Œå®‰å…¨æœºåˆ¶ã€‚

---

## ğŸ“¦ FlowContext ä¸Šä¸‹æ–‡ç»“æ„

å·¥ä½œæµä½¿ç”¨ `FlowContext` ä½œä¸ºå…¨å±€ä¸Šä¸‹æ–‡ï¼Œé‡‡ç”¨**é”®å€¼å¯¹æ˜ å°„**å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„è¾“å‡ºæ•°æ®ï¼š

```typescript
// å®šä¹‰äº src/types/flow.ts

export interface FlowContextMeta {
  flowId?: string | null;   // å½“å‰å·¥ä½œæµ ID
  sessionId?: string;        // ä¼šè¯ IDï¼ˆç”¨äºå¯¹è¯è®°å¿†ï¼‰
  nodeLabels?: Record<string, string>;  // nodeId â†’ label æ˜ å°„
}

export interface FlowContext {
  [nodeId: string]: Record<string, unknown> | FlowContextMeta | undefined;
  _meta?: FlowContextMeta;  // å…ƒæ•°æ®ï¼ˆä»¥ _ å¼€å¤´ï¼‰
}
```

### ä¸Šä¸‹æ–‡ç¤ºä¾‹

```
{
  "input_abc123": {
    "user_input": "å¸®æˆ‘å†™ä¸€ç¯‡æ–‡ç« ",
    "files": [],
    "formData": {}
  },
  "llm_def456": {
    "response": "è¿™æ˜¯ç”Ÿæˆçš„æ–‡ç« å†…å®¹..."
  },
  "tool_ghi789": {
    "formatted": "2025-12-15 12:00:00",
    "timestamp": 1734220800000,
    "timezone": "Asia/Shanghai"
  },
  "_meta": {
    "flowId": "flow_xyz",
    "sessionId": "session_123",
    "nodeLabels": {
      "input_abc123": "ç”¨æˆ·è¾“å…¥",
      "llm_def456": "æ–‡ç« ç”Ÿæˆ",
      "tool_ghi789": "è·å–å½“å‰æ—¶é—´"
    }
  }
}
```

### ä¸Šä¸‹æ–‡æ•°æ®è®¿é—®å·¥å…·

ç³»ç»Ÿæä¾›æ ‡å‡†åŒ–çš„ä¸Šä¸‹æ–‡è®¿é—®å‡½æ•°ï¼Œå®šä¹‰äº [contextUtils.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/contextUtils.ts)ï¼š

| å‡½æ•° | åŠŸèƒ½ |
|------|------|
| `getUpstreamData(context)` | è·å–ç¬¬ä¸€ä¸ªä¸Šæ¸¸èŠ‚ç‚¹çš„è¾“å‡ºæ•°æ® |
| `getUpstreamEntries(context)` | è·å–æ‰€æœ‰ä¸Šæ¸¸èŠ‚ç‚¹çš„ `[nodeId, output]` æ•°ç»„ |
| `extractTextFromUpstream(data)` | æ™ºèƒ½æå–æ–‡æœ¬å†…å®¹ |
| `extractInputFromContext(context)` | ç»„åˆæå–è¾“å…¥æ–‡æœ¬ |
| `extractOutputFromContext(nodes, context)` | æå– Output èŠ‚ç‚¹çš„å®Œæ•´è¾“å‡ºï¼ˆå«é™„ä»¶ï¼‰ |

---

## ğŸ“Š èŠ‚ç‚¹è¾“å‡ºæ ‡å‡†æ ¼å¼

| èŠ‚ç‚¹ç±»å‹ | ä¸»è¦è¾“å‡ºå­—æ®µ | è¯´æ˜ |
|---------|-------------|------|
| **Input** | `user_input`, `files`, `formData` | ç”¨æˆ·è¾“å…¥çš„æ–‡æœ¬ã€æ–‡ä»¶å’Œè¡¨å•æ•°æ® |
| **LLM** | `response` | AI ç”Ÿæˆçš„å›å¤å†…å®¹ï¼ˆæ”¯æŒæµå¼ï¼‰ |
| **RAG** | `query`, `documents`, `citations`, `documentCount` | æ£€ç´¢æŸ¥è¯¢åŠç»“æœ |
| **Tool** | å·¥å…·ç‰¹å®šå­—æ®µ | æ ¹æ®å·¥å…·ç±»å‹ä¸åŒï¼Œå¦‚ `formatted`, `results`, `content` ç­‰ |
| **Branch** | `conditionResult`, `passed`, + é€ä¼ æ•°æ® | æ¡ä»¶åˆ¤æ–­ç»“æœåŠä¸Šæ¸¸æ•°æ®é€ä¼  |
| **Output** | `text`, `attachments` | æœ€ç»ˆå±•ç¤ºæ–‡æœ¬å’Œé™„ä»¶åˆ—è¡¨ |

---

## ğŸ”— å˜é‡å¼•ç”¨æœºåˆ¶

### æ”¯æŒçš„å¼•ç”¨æ ¼å¼

| æ ¼å¼ | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| `{{field_name}}` | ç›´æ¥ä½¿ç”¨å­—æ®µåï¼ˆåœ¨æ‰€æœ‰ä¸Šæ¸¸èŠ‚ç‚¹ä¸­æŸ¥æ‰¾ï¼‰ | `{{user_input}}`, `{{response}}` |
| `{{èŠ‚ç‚¹åç§°.field_name}}` | ä½¿ç”¨èŠ‚ç‚¹ label å‰ç¼€ï¼ˆ**æ¨è**ï¼Œæ›´æ˜ç¡®ï¼‰ | `{{è·å–å½“å‰æ—¶é—´.formatted}}` |
| `{{node_id.field_name}}` | ä½¿ç”¨èŠ‚ç‚¹ ID å‰ç¼€ | `{{tool_abc123.formatted}}` |

### å˜é‡æ”¶é›†æµç¨‹

å˜é‡æ”¶é›†ç”± [variableUtils.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/utils/variableUtils.ts) ä¸­çš„ `collectVariables()` å‡½æ•°å®ç°ï¼š

``mermaid
flowchart TD
    A[å¼€å§‹æ”¶é›†å˜é‡] --> B{æ˜¯å¦è°ƒè¯•æ¨¡å¼?}
    B -->|æ˜¯| C[ä½¿ç”¨ Mock æ•°æ®]
    C --> Z[è¿”å›å˜é‡æ˜ å°„]
    B -->|å¦| D[éå†å…¨å±€ flowContext]
    D --> E[å±•å¼€èŠ‚ç‚¹è¾“å‡ºä¸ºå˜é‡<br/>è·³è¿‡ç›´æ¥ä¸Šæ¸¸]
    E --> F[éå†ç›´æ¥ä¸Šæ¸¸ context]
    F --> G[å±•å¼€ç›´æ¥ä¸Šæ¸¸è¾“å‡º<br/>è¦†ç›–åŒåå˜é‡]
    G --> H[æ·»åŠ è‡ªå®šä¹‰è¾“å‡ºå˜é‡]
    H --> Z
```

### å˜é‡æ”¶é›†ç®—æ³•

```typescript
function collectVariables(context, globalFlowContext, allNodes, mockData?) {
  const allVariables = {};
  
  // 1. è°ƒè¯•æ¨¡å¼ï¼šç›´æ¥ä½¿ç”¨ mock æ•°æ®
  if (mockData && Object.keys(mockData).length > 0) {
    Object.entries(mockData).forEach(([key, value]) => {
      allVariables[key] = String(value);
    });
    return allVariables;
  }
  
  // 2. å…ˆä»å…¨å±€ flowContext æå–ï¼ˆè¾ƒæ—©æ‰§è¡Œçš„èŠ‚ç‚¹ï¼‰
  for (const [nodeId, nodeOutput] of Object.entries(globalFlowContext)) {
    if (nodeId.startsWith('_')) continue;
    if (context[nodeId]) continue;  // è·³è¿‡ç›´æ¥ä¸Šæ¸¸ï¼ˆåé¢å¤„ç†ï¼‰
    
    const nodeLabel = findNodeLabel(nodeId, allNodes);
    flattenObject(nodeOutput, allVariables);            // {{fieldName}}
    flattenObject(nodeOutput, allVariables, nodeLabel); // {{èŠ‚ç‚¹åç§°.fieldName}}
    flattenObject(nodeOutput, allVariables, nodeId);    // {{nodeId.fieldName}}
    addCustomOutputs(nodeId, allVariables);
  }
  
  // 3. æœ€åä»ç›´æ¥ä¸Šæ¸¸ context æå–ï¼ˆä¼šè¦†ç›–å…¨å±€åŒåå˜é‡ï¼‰
  for (const [nodeId, nodeOutput] of Object.entries(context)) {
    if (nodeId.startsWith('_')) continue;
    
    flattenObject(nodeOutput, allVariables);            // ç›´æ¥ä¸Šæ¸¸ä¼˜å…ˆ
    flattenObject(nodeOutput, allVariables, nodeLabel);
    flattenObject(nodeOutput, allVariables, nodeId);
    addCustomOutputs(nodeId, allVariables);
  }
  
  return allVariables;
}
```

### å˜é‡ä¼˜å…ˆçº§

1. **ç›´æ¥ä¸Šæ¸¸** context ä¸­çš„èŠ‚ç‚¹è¾“å‡ºï¼ˆ**æœ€é«˜ä¼˜å…ˆçº§**ï¼‰
2. **å…¨å±€** flowContext ä¸­çš„èŠ‚ç‚¹è¾“å‡º

### å˜é‡æœªæ‰¾åˆ°æ—¶çš„å¤„ç†

- æ›¿æ¢ä¸º**ç©ºå­—ç¬¦ä¸²**
- æ§åˆ¶å°è¾“å‡ºè­¦å‘Šï¼š`[PromptParser] æœªæ‰¾åˆ°å˜é‡: xxxï¼Œå·²æ›¿æ¢ä¸ºç©ºå­—ç¬¦ä¸²`

### flattenObject å±•å¼€è§„åˆ™

| æ•°æ®ç±»å‹ | å¤„ç†æ–¹å¼ |
|---------|---------|
| `null` / `undefined` | ç©ºå­—ç¬¦ä¸² `""` |
| åŸºç¡€ç±»å‹ | `String(value)` |
| åµŒå¥—å¯¹è±¡ | é€’å½’å±•å¼€ï¼Œå¦‚ `obj.a.b` â†’ `{{a.b}}` |
| æ•°ç»„ | `JSON.stringify(array)` |
| `_` å¼€å¤´çš„é”® | **è·³è¿‡**ï¼ˆå†…éƒ¨å­—æ®µï¼‰ |

---

## ğŸ“ æ–‡æœ¬æå–ä¼˜å…ˆçº§

`extractTextFromUpstream()` å‡½æ•°æŒ‰ä»¥ä¸‹ä¼˜å…ˆçº§æ™ºèƒ½æå–æ–‡æœ¬ï¼š

```typescript
const TEXT_FIELD_PRIORITY = ['text', 'response', 'user_input', 'query'];
```

### æå–æµç¨‹

``mermaid
flowchart LR
    A[è¾“å…¥æ•°æ®] --> B{æ•°æ®ç±»å‹?}
    B -->|string| C[ç›´æ¥è¿”å›]
    B -->|é object| D[String è½¬æ¢]
    B -->|object| E[æŒ‰ä¼˜å…ˆçº§æŸ¥æ‰¾å­—æ®µ]
    E --> F{æ‰¾åˆ°éç©ºå­—æ®µ?}
    F -->|æ˜¯| G[è¿”å›å­—æ®µå€¼]
    F -->|å¦| H{æ˜¯ Branch è¾“å‡º?}
    H -->|æ˜¯| I[è¿‡æ»¤å…ƒæ•°æ®åå†æ¬¡æŸ¥æ‰¾]
    H -->|å¦| J[JSON stringify å…œåº•]
```

### Branch èŠ‚ç‚¹ç‰¹æ®Šå¤„ç†

```
const BRANCH_METADATA_FIELDS = ['conditionResult', 'passed', 'value'];

// Branch è¾“å‡ºä¸­ä¼šè¿‡æ»¤è¿™äº›å…ƒæ•°æ®å­—æ®µåå†æå–æ–‡æœ¬
```

---

## âš¡ å¹¶è¡Œæ‰§è¡Œå¼•æ“

ç³»ç»Ÿä½¿ç”¨åŸºäº**æ‹“æ‰‘å±‚çº§**çš„å¹¶è¡Œæ‰§è¡Œå¼•æ“ï¼Œå®šä¹‰äº [executionActions.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/actions/executionActions.ts) å’Œ [parallelExecutionUtils.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/utils/parallelExecutionUtils.ts)ã€‚

### æ‰§è¡Œæµç¨‹æ¦‚è§ˆ

``mermaid
flowchart TD
    A[runFlow å¼€å§‹] --> B[å¾ªç¯ä¾èµ–æ£€æµ‹]
    B --> C{æœ‰å¾ªç¯?}
    C -->|æ˜¯| D[ä¸­æ­¢å¹¶æŠ¥é”™]
    C -->|å¦| E[è¾“å…¥éªŒè¯]
    E --> F{è¾“å…¥å®Œæ•´?}
    F -->|å¦| G[æ‰“å¼€è¾“å…¥å¯¹è¯æ¡†]
    F -->|æ˜¯| H[è·å–æ‰§è¡Œé”]
    H --> I{é”å†²çª?}
    I -->|æ˜¯| J[è­¦å‘Šå¹¶è¿”å›]
    I -->|å¦| K[é‡ç½®æ‰§è¡ŒçŠ¶æ€]
    K --> L[åˆå§‹åŒ–æµå¼æ¨¡å¼]
    L --> M[æ„å»º FlowContext]
    M --> N[è®¡ç®—æ‹“æ‰‘å±‚çº§]
    N --> O[æŒ‰å±‚çº§å¹¶è¡Œæ‰§è¡Œ]
    O --> P[é‡Šæ”¾æ‰§è¡Œé”]
    P --> Q[å®Œæˆ]
```

### æ‹“æ‰‘å±‚çº§è®¡ç®—

``typescript
// src/store/utils/parallelExecutionUtils.ts

function calculateTopologicalLevels(nodes, edges): Map<nodeId, level> {
  // Level 0 = å…¥å£èŠ‚ç‚¹ï¼ˆæ— ä¸Šæ¸¸ä¾èµ–ï¼‰
  // Level N = max(æ‰€æœ‰å‰ç½®èŠ‚ç‚¹å±‚çº§) + 1
  
  const calculateLevel = (nodeId) => {
    const incomers = getIncomers(node, nodes, edges);
    if (incomers.length === 0) return 0;  // å…¥å£èŠ‚ç‚¹
    
    let maxUpstreamLevel = -1;
    for (const incomer of incomers) {
      maxUpstreamLevel = Math.max(maxUpstreamLevel, calculateLevel(incomer.id));
    }
    return maxUpstreamLevel + 1;
  };
}
```

### å±‚çº§å¹¶è¡Œæ‰§è¡Œ

```
graph LR
    subgraph "Level 0"
        A[Input]
    end
    subgraph "Level 1"
        B[LLM-1]
        C[RAG]
    end
    subgraph "Level 2"
        D[Branch]
    end
    subgraph "Level 3"
        E[LLM-2]
        F[Tool]
    end
    subgraph "Level 4"
        G[Output]
    end
    A --> B
    A --> C
    B --> D
    C --> D
    D --> E
    D --> F
    E --> G
    F --> G
```

**æ‰§è¡Œè§„åˆ™**ï¼š
- åŒå±‚çº§èŠ‚ç‚¹**å¹¶è¡Œæ‰§è¡Œ**ï¼ˆ`Promise.allSettled`ï¼‰
- ç­‰å¾…å½“å‰å±‚çº§å…¨éƒ¨å®Œæˆåï¼Œæ‰æ‰§è¡Œä¸‹ä¸€å±‚çº§
- ä»»ä¸€èŠ‚ç‚¹æ‰§è¡Œå¤±è´¥ä¼šè®°å½•é”™è¯¯å¹¶åœ¨å½“å‰å±‚çº§ç»“æŸåä¸­æ­¢

### æ‰§è¡Œé”æœºåˆ¶

```
// é˜²æ­¢å¹¶å‘æ‰§è¡Œ
if (get()._executionLock) {
  console.warn('[RunFlow] æ‰§è¡Œå·²åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆ');
  return;
}
set({ _executionLock: true });

try {
  // æ‰§è¡Œå·¥ä½œæµ...
} finally {
  set({ _executionLock: false });  // ç¡®ä¿é‡Šæ”¾é”
}
```

---

## ğŸŒ³ åˆ†æ”¯èŠ‚ç‚¹æ‰§è¡Œ

Branch èŠ‚ç‚¹ä½¿ç”¨**å®‰å…¨è¡¨è¾¾å¼æ±‚å€¼å™¨**ï¼Œè¯¦è§ [BranchNodeExecutor.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/BranchNodeExecutor.ts)ã€‚

### æ”¯æŒçš„æ¡ä»¶è¡¨è¾¾å¼

| è¡¨è¾¾å¼ç±»å‹ | æ ¼å¼ | ç¤ºä¾‹ |
|-----------|------|------|
| **åŒ…å«åˆ¤æ–­** | `èŠ‚ç‚¹å.å­—æ®µ.includes('å…³é”®è¯')` | `LLM1.response.includes('æˆåŠŸ')` |
| **å‰ç¼€åˆ¤æ–­** | `èŠ‚ç‚¹å.å­—æ®µ.startsWith('å‰ç¼€')` | `Input.text.startsWith('æŸ¥è¯¢')` |
| **åç¼€åˆ¤æ–­** | `èŠ‚ç‚¹å.å­—æ®µ.endsWith('åç¼€')` | `Tool.result.endsWith('.pdf')` |
| **ç›¸ç­‰åˆ¤æ–­** | `èŠ‚ç‚¹å.å­—æ®µ === 'value'` | `Branch.status === 'active'` |
| **ä¸ç­‰åˆ¤æ–­** | `èŠ‚ç‚¹å.å­—æ®µ !== 'value'` | `LLM.type !== 'error'` |
| **æ•°å€¼æ¯”è¾ƒ** | `èŠ‚ç‚¹å.å­—æ®µ > æ•°å€¼` | `Score.value >= 60` |
| **é•¿åº¦æ¯”è¾ƒ** | `èŠ‚ç‚¹å.å­—æ®µ.length > æ•°å€¼` | `Input.text.length > 10` |

### å®‰å…¨æ±‚å€¼æœºåˆ¶

```
// é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ï¼ˆæ¨¡å—çº§åˆ«ï¼Œé¿å…é‡å¤åˆ›å»ºï¼‰
const INCLUDES_PATTERN = /^([...]).includes\(['"](.*)['"]\)$/;
const COMPARISON_PATTERN = /^([...])([>=<])(\d+)$/;

function safeEvaluateCondition(condition, context): boolean {
  // 1. æ„å»ºèŠ‚ç‚¹æŸ¥æ‰¾ Mapï¼ˆO(1) æŸ¥æ‰¾ï¼‰
  const lookupMap = buildNodeLookupMap(context);
  
  // 2. ç™½åå•æ¨¡å¼åŒ¹é…
  const includesMatch = condition.match(INCLUDES_PATTERN);
  if (includesMatch) {
    // å®‰å…¨æ‰§è¡Œ includes æ£€æŸ¥
    return value.includes(searchStr);
  }
  
  // 3. ä¸æ”¯æŒçš„è¡¨è¾¾å¼ â†’ è¿”å› false + è­¦å‘Š
  console.warn('Unsupported condition format:', condition);
  return false;
}
```

### åˆ†æ”¯è·¯å¾„æ§åˆ¶

```
graph TD
    A[ä¸Šæ¸¸èŠ‚ç‚¹] --> B[Branch]
    B -->|conditionResult=true| C[TRUE è·¯å¾„]
    B -->|conditionResult=false| D[FALSE è·¯å¾„]
    C --> E[ä¸‹æ¸¸èŠ‚ç‚¹ A]
    D --> F[ä¸‹æ¸¸èŠ‚ç‚¹ B]
    E --> G[æ±‡åˆèŠ‚ç‚¹]
    F --> G
```

**è·¯å¾„é˜»å¡æœºåˆ¶**ï¼š
1. Branch èŠ‚ç‚¹æ‰§è¡Œåè¿”å› `conditionResult: boolean`
2. æ ¹æ®ç»“æœç¡®å®šæœªé€‰ä¸­çš„ handleï¼ˆ`true` â†’ é˜»å¡ `false` è·¯å¾„ï¼‰
3. ä½¿ç”¨ `getDescendants()` è·å–æœªé€‰ä¸­è·¯å¾„çš„æ‰€æœ‰ä¸‹æ¸¸èŠ‚ç‚¹
4. å°†è¿™äº›èŠ‚ç‚¹åŠ å…¥ `blockedNodes` é›†åˆï¼Œåç»­å±‚çº§æ‰§è¡Œæ—¶è·³è¿‡

```
if (node.type === 'branch' && result) {
  const conditionResult = !!result.conditionResult;
  const notTakenHandle = conditionResult ? 'false' : 'true';
  
  // è·å–å¹¶é˜»å¡æœªé€‰ä¸­åˆ†æ”¯çš„æ‰€æœ‰ä¸‹æ¸¸
  const blockedDescendants = getDescendants(nodeId, edges, notTakenHandle);
  blockedDescendants.forEach(id => blockedNodes.add(id));
}
```

---

## ğŸ”„ å¾ªç¯ä¾èµ–æ£€æµ‹

ç³»ç»Ÿä½¿ç”¨ DFS ç®—æ³•æ£€æµ‹ DAG ä¸­çš„å¾ªç¯ï¼Œå®šä¹‰äº [cycleDetection.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/utils/cycleDetection.ts)ã€‚

```
function hasCycle(nodeId, nodes, edges, visited = new Set(), stack = new Set()): boolean {
  if (stack.has(nodeId)) return true;   // å½“å‰è·¯å¾„ä¸­å·²å­˜åœ¨ â†’ å¾ªç¯
  if (visited.has(nodeId)) return false; // å·²è®¿é—®è¿‡ä¸”æ— å¾ªç¯
  
  visited.add(nodeId);
  stack.add(nodeId);  // åŠ å…¥å½“å‰è·¯å¾„æ ˆ
  
  const outgoers = getOutgoers({ id: nodeId }, nodes, edges);
  for (const out of outgoers) {
    if (hasCycle(out.id, nodes, edges, visited, stack)) return true;
  }
  
  stack.delete(nodeId);  // å›æº¯æ—¶ç§»å‡ºè·¯å¾„æ ˆ
  return false;
}
```

**æ‰§è¡Œæ—¶æœº**ï¼šå·¥ä½œæµæ‰§è¡Œå‰ï¼Œå¯¹æ¯ä¸ªèŠ‚ç‚¹è¿›è¡Œå¾ªç¯æ£€æµ‹ã€‚

**æ€§èƒ½ä¼˜åŒ–**ï¼š
- **visited å‰ªæ**: å·²æ£€æµ‹è¿‡çš„æ— ç¯å­å›¾ä¸ä¼šé‡å¤æ£€æµ‹
- **æ—¶é—´å¤æ‚åº¦**: O(V + E)ï¼Œå…¶ä¸­ V æ˜¯èŠ‚ç‚¹æ•°ï¼ŒE æ˜¯è¾¹æ•°
- **ç©ºé—´å¤æ‚åº¦**: O(V)ï¼Œç”¨äºå­˜å‚¨ visited å’Œ stack é›†åˆ

**å¾ªç¯ç¤ºä¾‹**ï¼š
```
A â†’ B â†’ C â†’ A  (å¾ªç¯ä¾èµ–ï¼Œè¢«æ£€æµ‹åˆ°)
A â†’ B â†’ C â†’ D  (æ­£å¸¸ DAGï¼Œé€šè¿‡æ£€æµ‹)
```

---

## ğŸ” èŠ‚ç‚¹è§£æå·¥å…·

å®šä¹‰äº [sourceResolver.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/utils/sourceResolver.ts)ï¼Œæä¾›é«˜æ€§èƒ½çš„èŠ‚ç‚¹æŸ¥æ‰¾èƒ½åŠ›ã€‚

### èŠ‚ç‚¹ç´¢å¼•ç»“æ„

```
export interface NodeIndex {
    byId: Map<string, AppNode>;     // nodeId â†’ node (O(1) æŸ¥æ‰¾)
    byLabel: Map<string, AppNode>;  // label â†’ node (O(1) æŸ¥æ‰¾)
}

/**
 * æ„å»ºèŠ‚ç‚¹æŸ¥æ‰¾ç´¢å¼•
 * O(n) æ„å»ºï¼Œæ”¯æŒ O(1) æŸ¥æ‰¾
 */
export function buildNodeIndex(nodes: AppNode[]): NodeIndex {
    const byId = new Map<string, AppNode>();
    const byLabel = new Map<string, AppNode>();

    for (const node of nodes) {
        byId.set(node.id, node);
        const label = node.data?.label as string | undefined;
        if (label) {
            byLabel.set(label, node);
        }
    }

    return { byId, byLabel };
}
```

### å˜é‡å¼•ç”¨è§£æ

```
/**
 * ä»å˜é‡å¼•ç”¨ä¸­æå–èŠ‚ç‚¹ ID
 * è¾“å…¥: "{{LLM1.response}}" æˆ– "{{èŠ‚ç‚¹å.å­—æ®µ}}"
 * è¾“å‡º: å¯¹åº”çš„ nodeId æˆ– null
 */
export function resolveSourceNodeId(
    value: string,
    nodes: AppNode[]
): string | null {
    // æå– {{xxx}} ä¸­çš„å˜é‡å
    const match = value.match(/\{\{(.+?)\}\}/);
    if (!match) return null;

    const varPath = match[1]; // ä¾‹å¦‚ "LLM1.response" æˆ– "response"

    // å°è¯•åŒ¹é… "èŠ‚ç‚¹å.å­—æ®µ" æ ¼å¼
    const dotIndex = varPath.indexOf('.');
    if (dotIndex > 0) {
        const nodeLabel = varPath.substring(0, dotIndex);
        // å…ˆåŒ¹é… labelï¼Œå†åŒ¹é… ID
        const matchedNode = nodes.find(n =>
            (n.data?.label as string) === nodeLabel ||
            n.id === nodeLabel
        );
        if (matchedNode) return matchedNode.id;
    }

    // å°è¯•ç›´æ¥åŒ¹é…èŠ‚ç‚¹ label æˆ– ID
    const directMatch = nodes.find(n =>
        (n.data?.label as string) === varPath ||
        n.id === varPath
    );
    if (directMatch) return directMatch.id;

    return null;
}
```

**ä½¿ç”¨åœºæ™¯**ï¼š
- Output èŠ‚ç‚¹çš„ `inputMappings.sources` è§£æ
- æµå¼è¾“å‡ºæºèŠ‚ç‚¹å®šä½ï¼ˆ`initSegmentedStreaming`, `initSelectStreaming`ï¼‰

---

## ğŸ”§ èŠ‚ç‚¹æ‰§è¡Œå™¨æ¶æ„

æ‰€æœ‰èŠ‚ç‚¹æ‰§è¡Œå™¨ç»Ÿä¸€ç”± [NodeExecutorFactory](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/NodeExecutorFactory.ts) ç®¡ç†ï¼š

```
// src/store/executors/NodeExecutorFactory.ts

export class NodeExecutorFactory {
    private static executors: Record<NodeKind, NodeExecutor> = {
        input: new InputNodeExecutor(),
        llm: new LLMNodeExecutor(),
        rag: new RAGNodeExecutor(),
        output: new OutputNodeExecutor(),
        branch: new BranchNodeExecutor(),
        tool: new ToolNodeExecutor(),
    };

    static getExecutor(nodeType: NodeKind): NodeExecutor {
        const executor = this.executors[nodeType];
        if (!executor) {
            throw new Error(`No executor found for node type: ${nodeType}`);
        }
        return executor;
    }
}
```

### æ‰§è¡Œå™¨è°ƒç”¨æ–¹å¼

```
// executionActions.ts - executeSingleNode()

const executor = NodeExecutorFactory.getExecutor(node.type);
const { output, executionTime } = await executor.execute(node, upstreamContext);
```

### æ ¸å¿ƒæ‰§è¡Œå™¨åˆ—è¡¨

| æ‰§è¡Œå™¨ç±» | èŠ‚ç‚¹ç±»å‹ | ä¸»è¦åŠŸèƒ½ | æ–‡ä»¶è·¯å¾„ |
|---------|---------|---------|----------|
| `InputNodeExecutor` | `input` | æå–ç”¨æˆ·è¾“å…¥ï¼ˆ`user_input`, `files`, `formData`ï¼‰ | `InputNodeExecutor.ts` |
| `LLMNodeExecutor` | `llm` | è°ƒç”¨ LLM APIï¼Œæ”¯æŒæµå¼è¾“å‡ºå’Œå¯¹è¯è®°å¿† | `LLMNodeExecutor.ts` |
| `RAGNodeExecutor` | `rag` | Gemini File Search æ£€ç´¢ | `RAGNodeExecutor.ts` |
| `OutputNodeExecutor` | `output` | 4 ç§æ¨¡å¼ï¼ˆdirect/select/merge/templateï¼‰+ é™„ä»¶è§£æ | `OutputNodeExecutor.ts` |
| `BranchNodeExecutor` | `branch` | å®‰å…¨è¡¨è¾¾å¼æ±‚å€¼ + ä¸Šæ¸¸æ•°æ®é€ä¼  | `BranchNodeExecutor.ts` |
| `ToolNodeExecutor` | `tool` | å·¥å…·æ‰§è¡Œ + Zod Schema éªŒè¯ | `ToolNodeExecutor.ts` |

---

## ğŸ›¡ï¸ å®‰å…¨ä¸å®¹é”™æœºåˆ¶

### 1. å‚æ•°éªŒè¯

| èŠ‚ç‚¹ç±»å‹ | éªŒè¯æœºåˆ¶ | å¤±è´¥å¤„ç† |
|---------|---------|----------|
| **Input** | æ–‡æœ¬/æ–‡ä»¶/è¡¨å•å¿…å¡«é¡¹æ£€æŸ¥ï¼ˆ`enableTextInput`, `enableFileInput`, `enableStructuredForm`ï¼‰ | æ‰“å¼€ `InputPromptDialog` æç¤ºè¾“å…¥ |
| **LLM** | `systemPrompt` éç©ºã€`temperature` èŒƒå›´éªŒè¯ | æŠ›å‡ºå¼‚å¸¸ï¼Œè®¾ç½® `executionStatus: "error"` |
| **RAG** | `files` æ•°ç»„éç©ºã€`fileSearchStoreName` å·²é…ç½® | æŠ›å‡ºå¼‚å¸¸ |
| **Tool** | Zod Schema äºŒæ¬¡éªŒè¯ï¼ˆåœ¨å·¥å…·å®šä¹‰ä¸­å£°æ˜ï¼‰ | éªŒè¯å¤±è´¥æŠ›å‡ºè¯¦ç»†é”™è¯¯ä¿¡æ¯ |
| **Branch** | ç™½åå•è¡¨è¾¾å¼åŒ¹é…ï¼ˆéç™½åå•è¿”å› false + è­¦å‘Šï¼‰ | æ§åˆ¶å°è­¦å‘Š + é»˜è®¤ false |
| **Output** | æ¨¡å¼ä¸é…ç½®ä¸€è‡´æ€§æ£€æŸ¥ï¼ˆ`sources` éç©ºã€`template` å­˜åœ¨ï¼‰ | æŠ›å‡ºé…ç½®é”™è¯¯å¼‚å¸¸ |

### 2. æ•æ„Ÿæ•°æ®è¿‡æ»¤

| åœºæ™¯ | è¿‡æ»¤è§„åˆ™ | å®ç°ä½ç½® |
|------|---------|----------|
| **Branch é€ä¼ ** | è¿‡æ»¤ `_` å¼€å¤´å­—æ®µï¼ˆ`_meta` ç­‰ï¼‰ | `BranchNodeExecutor.ts` L233-237 |
| **FlowContext è®¿é—®** | `getUpstreamEntries` è¿‡æ»¤ `_meta` | `contextUtils.ts` L11-28 |
| **å˜é‡æ”¶é›†** | `flattenObject` è·³è¿‡ `_` å¼€å¤´çš„é”® | `variableUtils.ts` L29 |
| **æ–‡æœ¬æå–** | è¿‡æ»¤ `conditionResult`, `passed`, `value` | `contextUtils.ts` L46, L84-88 |

### 3. æ‰§è¡Œå®Œæ•´æ€§æ£€æŸ¥

é˜²æ­¢æ‰§è¡ŒæœŸé—´èŠ‚ç‚¹è¢«åˆ é™¤å¯¼è‡´çŠ¶æ€æ··ä¹±ï¼š

```
// executionActions.ts - runFlow()

const initialNodeIds = new Set(nodes.map((n: AppNode) => n.id));

const checkFlowIntegrity = () => {
    const currentNodes = get().nodes;
    const currentIds = new Set(currentNodes.map((n: AppNode) => n.id));
    for (const id of initialNodeIds) {
        if (!currentIds.has(id)) {
            throw new Error(
                "Execution interrupted: Flow structure changed (node deleted)."
            );
        }
    }
};

// åœ¨å…³é”®èŠ‚ç‚¹æ‰§è¡Œå‰è°ƒç”¨
for (let level = 0; level <= maxLevel; level++) {
    checkFlowIntegrity();  // æ£€æŸ¥å®Œæ•´æ€§
    // ...æ‰§è¡ŒèŠ‚ç‚¹
}
```

### 4. é”™è¯¯ä¼ æ’­æœºåˆ¶

```
// æ”¶é›†å±‚çº§å†…çš„æ‰§è¡Œé”™è¯¯
const executionErrors: { nodeId: string; error: Error }[] = [];

const results = await Promise.allSettled(
    executableNodes.map(nodeId => executeNodeAndHandleBranch(nodeId))
);

results.forEach((result, index) => {
    if (result.status === 'rejected') {
        executionErrors.push({
            nodeId: executableNodes[index],
            error: result.reason instanceof Error 
                ? result.reason 
                : new Error(String(result.reason))
        });
    }
});

// å¦‚æœæœ‰é”™è¯¯ï¼Œä¸­æ­¢åç»­å±‚çº§æ‰§è¡Œ
if (executionErrors.length > 0) {
    const errorMessages = executionErrors
        .map(e => `${e.nodeId}: ${e.error.message}`)
        .join('; ');
    throw new Error(`èŠ‚ç‚¹æ‰§è¡Œå¤±è´¥: ${errorMessages}`);
}
```

---

## ğŸšï¸ æµå¼è¾“å‡ºæ¨¡å¼

Output èŠ‚ç‚¹æ”¯æŒä¸‰ç§æµå¼è¾“å‡ºæ¨¡å¼ï¼Œç”± `inputMappings.mode` å†³å®šï¼š

| æ¨¡å¼ | è¯´æ˜ | åˆå§‹åŒ–å‡½æ•° | é€‚ç”¨åœºæ™¯ |
|------|------|-------------|----------|
| `single` | å•æºç›´æ¥è¾“å‡ºï¼ˆé»˜è®¤ï¼‰ | æ— ï¼ˆé»˜è®¤çŠ¶æ€ï¼‰ | å•ä¸ª LLM èŠ‚ç‚¹ç›´è¿ Output |
| `segmented` | åˆ†æ®µæµå¼ï¼ˆmerge æ¨¡å¼ï¼‰ | `initSegmentedStreaming(sourceIds)` | å¤šä¸ª LLM å¹¶è¡Œæ‰§è¡Œï¼Œé¡ºåºæ˜¾ç¤ºæ¯æ®µç»“æœ |
| `select` | é¦–å­—é”å®šï¼ˆselect æ¨¡å¼ï¼‰ | `initSelectStreaming(sourceIds)` | åˆ†æ”¯åœºæ™¯ï¼Œåªæ˜¾ç¤ºé¦–ä¸ªè¾“å‡ºçš„åˆ†æ”¯ |

### Single æ¨¡å¼ï¼ˆé»˜è®¤ï¼‰

```
// ç›´æ¥è®¾ç½® streamingText
// flowStore ä¸­çš„ appendStreamingText æ–¹æ³•ä¼šè‡ªåŠ¨è¿½åŠ å†…å®¹
appendStreamingText(chunk);  // chunk by chunk è¿½åŠ 
```

### Segmented æ¨¡å¼ï¼ˆmergeï¼‰

```
// åˆå§‹åŒ–ï¼šä¸ºæ¯ä¸ªæºåˆ›å»ºä¸€ä¸ª segment
initSegmentedStreaming(sourceIds: string[]) {
    set({
        streamingMode: 'segmented',
        streamingSegments: sourceIds.map(id => ({
            sourceId: id,
            content: '',
            status: 'waiting'
        }))
    });
}

// è¿½åŠ å†…å®¹ï¼šæ›´æ–°å¯¹åº” segment
appendToSegment(sourceId: string, chunk: string) {
    set((state) => ({
        streamingSegments: state.streamingSegments.map(seg =>
            seg.sourceId === sourceId
                ? { ...seg, content: seg.content + chunk, status: 'streaming' }
                : seg
        )
    }));
}

// å®Œæˆæ ‡è®°
completeSegment(sourceId: string) {
    set((state) => ({
        streamingSegments: state.streamingSegments.map(seg =>
            seg.sourceId === sourceId
                ? { ...seg, status: 'completed' }
                : seg
        )
    }));
}
```

### Select æ¨¡å¼ï¼ˆé¦–å­—é”å®šï¼‰

```
// åˆå§‹åŒ–
initSelectStreaming(sourceIds: string[]) {
    set({
        streamingMode: 'select',
        selectSourceIds: sourceIds,
        lockedSourceId: null  // å°šæœªé”å®š
    });
}

// å°è¯•é”å®šæºï¼ˆé¦–ä¸ªè¾“å‡ºå†…å®¹çš„èŠ‚ç‚¹ä¼šè¢«é”å®šï¼‰
tryLockSource(sourceId: string): boolean {
    const currentState = get();
    
    // å¦‚æœå°šæœªé”å®šï¼Œé”å®šè¯¥æº
    if (currentState.lockedSourceId === null) {
        set({ lockedSourceId: sourceId });
        return true;  // æˆåŠŸé”å®š
    }
    
    // å·²é”å®šåŒä¸€æºï¼Œå…è®¸ç»§ç»­è¾“å‡º
    return currentState.lockedSourceId === sourceId;
}
```

**ä½¿ç”¨åœºæ™¯ç¤ºä¾‹**ï¼š

```
# Segmented æ¨¡å¼ï¼ˆmergeï¼‰
Input â†’ LLM1 (æ€»ç»“)
      â†’ LLM2 (ç¿»è¯‘) 
      â†’ Output (merge: [LLM1, LLM2])
      
ç»“æœ: ä¾æ¬¡æ˜¾ç¤º LLM1 çš„æµå¼è¾“å‡ºï¼Œç„¶åæ˜¾ç¤º LLM2 çš„æµå¼è¾“å‡º

# Select æ¨¡å¼
Input â†’ Branch
      â”œâ”€ true â†’ LLM1
      â””â”€ false â†’ LLM2
      â†’ Output (select: [LLM1, LLM2])
      
ç»“æœ: åªæ˜¾ç¤ºé¦–ä¸ªå¼€å§‹è¾“å‡ºçš„ LLM èŠ‚ç‚¹çš„å†…å®¹
```

---

## âš ï¸ å¸¸è§é”™è¯¯ä¸å¤„ç†

| é”™è¯¯åœºæ™¯ | é”™è¯¯ä¿¡æ¯ | é¢„é˜²æªæ–½ | ä»£ç ä½ç½® |
|---------|---------|---------|----------|
| **å¾ªç¯ä¾èµ–** | `"æ£€æµ‹åˆ°å¾ªç¯ä¾èµ–ï¼Œæ— æ³•æ‰§è¡Œå·¥ä½œæµ"` | æ‰§è¡Œå‰ DFS æ£€æµ‹ | `executionActions.ts` L122-130 |
| **å¹¶å‘æ‰§è¡Œ** | `"æµç¨‹æ­£åœ¨æ‰§è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆåå†è¯•"` | `_executionLock` æ‰§è¡Œé” | `executionActions.ts` L170-174 |
| **èŠ‚ç‚¹åˆ é™¤** | `"Execution interrupted: Flow structure changed"` | `checkFlowIntegrity()` æ£€æŸ¥ | `executionActions.ts` L233-241 |
| **éæ³•è¡¨è¾¾å¼** | æ§åˆ¶å°è­¦å‘Š + é»˜è®¤ false | ç™½åå•æ¨¡å¼åŒ¹é… | `BranchNodeExecutor.ts` L158-160 |
| **å˜é‡æœªæ‰¾åˆ°** | `"[PromptParser] æœªæ‰¾åˆ°å˜é‡: xxx"` | æ§åˆ¶å°æ—¥å¿— + æ›¿æ¢ä¸ºç©º | `promptParser.ts` L73 |
| **è¾“å…¥ç¼ºå¤±** | æ‰“å¼€ `InputPromptDialog` | `runFlow` å¼€å§‹æ—¶éªŒè¯ | `executionActions.ts` L134-167 |
| **Output é…ç½®é”™** | `"Output èŠ‚ç‚¹é…ç½®é”™è¯¯: xxx"` | æ¨¡å¼ä¸ sources/template ä¸€è‡´æ€§æ£€æŸ¥ | `OutputNodeExecutor.ts` L164-211 |

---

## ğŸ“ æ ¸å¿ƒä»£ç æ–‡ä»¶ç´¢å¼•

### ç±»å‹å®šä¹‰
- [flow.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/types/flow.ts) - `FlowContext`, `FlowContextMeta`, `AppNode`, `AppEdge`, `FlowState` ç­‰æ ¸å¿ƒç±»å‹

### æ‰§è¡Œå¼•æ“
- [executionActions.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/actions/executionActions.ts) - `runFlow`, `runNode`, `executeSingleNode` æ‰§è¡Œä¸»å…¥å£
- [parallelExecutionUtils.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/utils/parallelExecutionUtils.ts) - æ‹“æ‰‘å±‚çº§è®¡ç®—ã€å¹¶è¡Œæ‰§è¡Œå·¥å…·
- [cycleDetection.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/utils/cycleDetection.ts) - å¾ªç¯ä¾èµ–æ£€æµ‹ç®—æ³•

### å˜é‡ç³»ç»Ÿ
- [variableUtils.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/utils/variableUtils.ts) - `collectVariables`, `flattenObject` å˜é‡æ”¶é›†ä¸å±•å¼€
- [promptParser.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/lib/promptParser.ts) - `replaceVariables`, `extractVariables` å˜é‡æ›¿æ¢é€»è¾‘
- [sourceResolver.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/utils/sourceResolver.ts) - èŠ‚ç‚¹è§£æä¸ç´¢å¼•å·¥å…·

### ä¸Šä¸‹æ–‡ç®¡ç†
- [contextUtils.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/contextUtils.ts) - ä¸Šä¸‹æ–‡æ•°æ®è®¿é—®å·¥å…·å‡½æ•°

### èŠ‚ç‚¹æ‰§è¡Œå™¨
- [NodeExecutorFactory.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/NodeExecutorFactory.ts) - æ‰§è¡Œå™¨å·¥å‚
- [InputNodeExecutor.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/InputNodeExecutor.ts) - Input èŠ‚ç‚¹æ‰§è¡Œå™¨
- [OutputNodeExecutor.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/OutputNodeExecutor.ts) - Output èŠ‚ç‚¹æ‰§è¡Œå™¨ï¼ˆ4 ç§æ¨¡å¼ï¼‰
- [BranchNodeExecutor.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/BranchNodeExecutor.ts) - Branch èŠ‚ç‚¹æ‰§è¡Œå™¨ï¼ˆå®‰å…¨è¡¨è¾¾å¼æ±‚å€¼ï¼‰
- [LLMNodeExecutor.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/LLMNodeExecutor.ts) - LLM èŠ‚ç‚¹æ‰§è¡Œå™¨ï¼ˆæµå¼è¾“å‡º + è®°å¿†ï¼‰
- [RAGNodeExecutor.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/RAGNodeExecutor.ts) - RAG èŠ‚ç‚¹æ‰§è¡Œå™¨
- [ToolNodeExecutor.ts](file:///Users/jasperlin/Desktop/product/flash-flow-saas/flash-flow/src/store/executors/ToolNodeExecutor.ts) - Tool èŠ‚ç‚¹æ‰§è¡Œå™¨

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. èŠ‚ç‚¹ç´¢å¼•ä¼˜åŒ–

```
// executionActions.ts - runFlow()
// ä½¿ç”¨ Map å­˜å‚¨é™æ€èŠ‚ç‚¹æ•°æ®ï¼Œé¿å…é‡å¤æŸ¥æ‰¾
const nodeMap = new Map<string, AppNode>(nodes.map((n: AppNode) => [n.id, n]));

// O(1) æŸ¥æ‰¾èŠ‚ç‚¹ç±»å‹
const node = nodeMap.get(nodeId);
```

### 2. æ­£åˆ™é¢„ç¼–è¯‘

```
// BranchNodeExecutor.ts - æ¨¡å—çº§åˆ«é¢„ç¼–è¯‘
const INCLUDES_PATTERN = /^([a-zA-Z\u4e00-\u9fa5_][\w\u4e00-\u9fa5]*\.[\w.]+)\.includes\(['"](.+)['"]\)$/;
// é¿å…æ¯æ¬¡æ‰§è¡Œæ—¶é‡å¤ç¼–è¯‘
```

### 3. è®°å¿†åŒ–ä¼˜åŒ–

```
// parallelExecutionUtils.ts - calculateTopologicalLevels()
const calculateLevel = (nodeId: string): number => {
    // å·²è®¡ç®—è¿‡ï¼Œç›´æ¥è¿”å›
    if (levels.has(nodeId)) {
        return levels.get(nodeId)!;
    }
    // ... è®¡ç®—é€»è¾‘
};
```

### 4. å¹¶è¡Œæ‰§è¡Œä¼˜åŒ–

```
// executionActions.ts
// åŒå±‚çº§èŠ‚ç‚¹å¹¶è¡Œæ‰§è¡Œï¼Œå¤§å¹…ç¼©çŸ­æ‰§è¡Œæ—¶é—´
const results = await Promise.allSettled(
    executableNodes.map(nodeId => executeNodeAndHandleBranch(nodeId))
);
```

### 5. å‰ªæä¼˜åŒ–

```
// cycleDetection.ts
// å·²æ£€æµ‹è¿‡çš„æ— ç¯å­å›¾ä¸ä¼šé‡å¤æ£€æµ‹
if (visited.has(nodeId)) return false;
```

---

## ğŸ” è°ƒè¯•å·¥å…·

### 1. å•èŠ‚ç‚¹è°ƒè¯•

```
// é€šè¿‡ runNode å‡½æ•°è°ƒè¯•å•ä¸ªèŠ‚ç‚¹
runNode(nodeId, mockInputData?: Record<string, unknown>)

// LLM èŠ‚ç‚¹ï¼šæ‰“å¼€ LLMDebugDialog
get().openLLMDebugDialog(nodeId);

// RAG èŠ‚ç‚¹ï¼šæ‰“å¼€ RAGDebugDialog
get().openRAGDebugDialog(nodeId);

// Tool èŠ‚ç‚¹ï¼šæ‰“å¼€ ToolDebugDialog
get().openToolDebugDialog(nodeId);
```

### 2. ä¸Šä¸‹æ–‡æŸ¥çœ‹

````
const context = useFlowStore.getState().flowContext;
console.log(context);

// æŸ¥çœ‹èŠ‚ç‚¹æ ‡ç­¾æ˜ å°„
console.log(context._meta?.nodeLabels);
```

### 3. æ—¥å¿—è¾“å‡º

- **å˜é‡æœªæ‰¾åˆ°**: `[PromptParser] æœªæ‰¾åˆ°å˜é‡: xxx`
- **éæ³•è¡¨è¾¾å¼**: `[BranchNodeExecutor] Unsupported condition format: xxx`
- **æ‰§è¡Œé”™è¯¯**: `executionError` çŠ¶æ€å­—æ®µä¸­çš„é”™è¯¯ä¿¡æ¯

---

## ğŸš€ æœ€ä½³å®è·µ

### 1. å˜é‡å¼•ç”¨
- **ä¼˜å…ˆä½¿ç”¨èŠ‚ç‚¹ label**: `{{è·å–æ—¶é—´.formatted}}` æ¯” `{{formatted}}` æ›´æ¸…æ™°
- **é¿å…åŒåå†²çª**: å¤šä¸ª LLM èŠ‚ç‚¹éƒ½è¾“å‡º `response` æ—¶ï¼Œä½¿ç”¨å¸¦å‰ç¼€çš„å¼•ç”¨
- **æ£€æŸ¥å˜é‡å­˜åœ¨**: æŸ¥çœ‹æ§åˆ¶å°è­¦å‘Šï¼Œç¡®ä¿å˜é‡å·²å®šä¹‰

### 2. åˆ†æ”¯è¡¨è¾¾å¼
- **ä½¿ç”¨èŠ‚ç‚¹ label**: `ç”¨æˆ·è¾“å…¥.user_input.includes('æŸ¥è¯¢')` æ¯” `input_xxx.user_input` æ›´å¯è¯»
- **é¿å…å¤æ‚è¡¨è¾¾å¼**: åªä½¿ç”¨ç™½åå•æ”¯æŒçš„æ ¼å¼
- **æµ‹è¯•è¡¨è¾¾å¼**: ä½¿ç”¨ `runNode` è°ƒè¯•åˆ†æ”¯é€»è¾‘

### 3. æµç¨‹è®¾è®¡
- **é¿å…å¾ªç¯**: ä¿æŒ DAG ç»“æ„
- **åˆç†åˆ†å±‚**: å……åˆ†åˆ©ç”¨å¹¶è¡Œæ‰§è¡Œï¼Œé¿å…ä¸å¿…è¦çš„ä¾èµ–
- **é™åˆ¶æ·±åº¦**: é¿å…è¿‡é•¿çš„ä¾èµ–é“¾

### 4. é”™è¯¯å¤„ç†
- **æä¾›é»˜è®¤å€¼**: Input èŠ‚ç‚¹é…ç½® `defaultValue`
- **éªŒè¯è¾“å…¥**: åœ¨æ‰§è¡Œå‰æ£€æŸ¥å¿…å¡«é¡¹
- **å¤„ç†å¼‚å¸¸**: æ•è·å¹¶å±•ç¤ºæœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯
