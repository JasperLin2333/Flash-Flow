import { escapeRegExp, extractVariables } from "@/lib/promptParser";
import { ensureBranchHandles } from "@/lib/branchHandleUtils";

type AnyNode = { id?: unknown; type?: unknown; data?: any };
type AnyEdge = { id?: unknown; source?: unknown; target?: unknown; sourceHandle?: unknown; [k: string]: unknown };

export interface SafeFixOptions {
  removeInvalidEdges?: boolean;
  dedupeEdges?: boolean;
  ensureEdgeIds?: boolean;
  replaceVariableIdPrefixToLabel?: boolean;
  normalizeEdgeEndpointsByLabel?: boolean;
}

export interface SafeFixResult {
  nodes: AnyNode[];
  edges: AnyEdge[];
  fixes: string[];
}

function parseVariablePrefix(varName: string): string {
  const dotIndex = varName.indexOf(".");
  const bracketIndex = varName.indexOf("[");
  const cut = dotIndex === -1 ? bracketIndex : bracketIndex === -1 ? dotIndex : Math.min(dotIndex, bracketIndex);
  return (cut === -1 ? varName : varName.slice(0, cut)).trim();
}

function normalizeRef(value: string): string {
  return value.trim().replace(/\s+/g, " ").toLowerCase();
}

function isSafeVariablePrefix(value: string): boolean {
  if (!value.trim()) return false;
  return !/[.\[\]\{\}]/.test(value);
}

function isAutoGeneratedId(value: string): boolean {
  const v = value.toLowerCase();
  if (v.startsWith("node_") || v.startsWith("edge_") || v.startsWith("auto_")) return true;
  if (/^[a-z]+-[a-z0-9]{4,}$/.test(v)) return true;
  return false;
}

function getStringFieldsToFix(node: AnyNode): Array<{ fieldPath: string; value: string }> {
  const result: Array<{ fieldPath: string; value: string }> = [];
  const type = String(node.type || "");
  const data = node.data || {};

  const pushIfString = (fieldPath: string, v: unknown) => {
    if (typeof v === "string" && v.includes("{{") && v.includes("}}")) {
      result.push({ fieldPath, value: v });
    }
  };

  if (type === "llm") {
    pushIfString("data.systemPrompt", data.systemPrompt);
    const mappings = data.inputMappings;
    if (mappings && typeof mappings === "object") {
      for (const [k, v] of Object.entries(mappings)) {
        pushIfString(`data.inputMappings.${k}`, v);
      }
    }
  }

  if (type === "rag") {
    const mappings = data.inputMappings;
    if (mappings && typeof mappings === "object") {
      for (const [k, v] of Object.entries(mappings)) {
        pushIfString(`data.inputMappings.${k}`, v);
      }
    }
  }

  if (type === "tool") {
    const inputs = data.inputs;
    if (inputs && typeof inputs === "object") {
      for (const [k, v] of Object.entries(inputs)) {
        pushIfString(`data.inputs.${k}`, v);
      }
    }
  }

  if (type === "output") {
    const im = data.inputMappings || {};
    pushIfString("data.inputMappings.template", im.template);
    const sources = Array.isArray(im.sources) ? im.sources : [];
    sources.forEach((s: any, i: number) => pushIfString(`data.inputMappings.sources[${i}].value`, s?.value));
    const attachments = Array.isArray(im.attachments) ? im.attachments : [];
    attachments.forEach((a: any, i: number) => pushIfString(`data.inputMappings.attachments[${i}].value`, a?.value));
  }

  if (type === "branch") {
    pushIfString("data.condition", data.condition);
  }

  if (type === "imagegen") {
    pushIfString("data.prompt", data.prompt);
    pushIfString("data.negativePrompt", data.negativePrompt);
    pushIfString("data.referenceImageVariable", data.referenceImageVariable);
    pushIfString("data.referenceImage2Variable", data.referenceImage2Variable);
    pushIfString("data.referenceImage3Variable", data.referenceImage3Variable);
  }

  return result;
}

function setValueAtPath(obj: any, fieldPath: string, value: string) {
  const parts = fieldPath.split(".").filter(Boolean);
  if (parts.length === 0) return;
  let cur = obj;
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    const arrayMatch = part.match(/^([^\[]+)\[(\d+)\]$/);
    if (arrayMatch) {
      const key = arrayMatch[1];
      const index = Number(arrayMatch[2]);
      if (!cur[key] || !Array.isArray(cur[key]) || !cur[key][index]) return;
      if (i === parts.length - 1) {
        cur[key][index] = value;
        return;
      }
      cur = cur[key][index];
    } else {
      if (i === parts.length - 1) {
        cur[part] = value;
        return;
      }
      if (!cur[part] || typeof cur[part] !== "object") return;
      cur = cur[part];
    }
  }
}

function rewriteOutsideQuotes(input: string, rewrite: (segment: string) => string): string {
  let out = "";
  let buf = "";
  let quote: "'" | '"' | null = null;

  for (let i = 0; i < input.length; i++) {
    const ch = input[i];
    if (quote) {
      out += ch;
      if (ch === quote && input[i - 1] !== "\\") {
        quote = null;
      }
      continue;
    }
    if (ch === "'" || ch === '"') {
      out += rewrite(buf);
      buf = "";
      quote = ch;
      out += ch;
      continue;
    }
    buf += ch;
  }

  out += rewrite(buf);
  return out;
}

export function safeFixWorkflowV1(rawNodes: unknown, rawEdges: unknown, options?: SafeFixOptions): SafeFixResult {
  const opts: Required<SafeFixOptions> = {
    removeInvalidEdges: options?.removeInvalidEdges ?? true,
    dedupeEdges: options?.dedupeEdges ?? true,
    ensureEdgeIds: options?.ensureEdgeIds ?? true,
    replaceVariableIdPrefixToLabel: options?.replaceVariableIdPrefixToLabel ?? true,
    normalizeEdgeEndpointsByLabel: options?.normalizeEdgeEndpointsByLabel ?? true,
  };

  const nodes: AnyNode[] = Array.isArray(rawNodes) ? JSON.parse(JSON.stringify(rawNodes)) : [];
  const edges: AnyEdge[] = Array.isArray(rawEdges) ? JSON.parse(JSON.stringify(rawEdges)) : [];
  const fixes: string[] = [];

  let forcedTextForFileUpload = 0;
  for (const n of nodes) {
    if (String(n?.type || "") !== "input") continue;
    const data = n?.data && typeof n.data === "object" ? n.data : {};
    if (data.enableFileInput !== true) continue;
    const needsEnableText = data.enableTextInput === false;
    const needsTextRequired = data.textRequired !== true;
    if (!needsEnableText && !needsTextRequired) continue;
    if (needsEnableText) data.enableTextInput = true;
    if (needsTextRequired) data.textRequired = true;
    n.data = data;
    forcedTextForFileUpload += 1;
  }
  if (forcedTextForFileUpload > 0) {
    fixes.push(`已为 ${forcedTextForFileUpload} 个 Input 节点补齐文件上传的文本必填规则`);
  }

  const idToLabel = new Map<string, string>();
  const idToType = new Map<string, string>();
  const labelToType = new Map<string, string>();
  const idLowerToId = new Map<string, string>();
  const labelNormToId = new Map<string, string>();
  const ambiguousLabelNorms = new Set<string>();
  const nodeIdSet = new Set<string>();
  for (const n of nodes) {
    const id = typeof n?.id === "string" ? n.id : "";
    if (!id) continue;
    nodeIdSet.add(id);
    nodeIdSet.add(id.toLowerCase());
    idLowerToId.set(id.toLowerCase(), id);
    idToType.set(id, String(n?.type || ""));
    idToType.set(id.toLowerCase(), String(n?.type || ""));
    const label = typeof n?.data?.label === "string" ? n.data.label : "";
    if (label) {
      idToLabel.set(id, label);
      idToLabel.set(id.toLowerCase(), label);
      labelToType.set(label, String(n?.type || ""));
      labelToType.set(label.toLowerCase(), String(n?.type || ""));
      const labelNorm = normalizeRef(label);
      if (labelNormToId.has(labelNorm) && labelNormToId.get(labelNorm) !== id) {
        ambiguousLabelNorms.add(labelNorm);
      } else {
        labelNormToId.set(labelNorm, id);
      }
    }
  }

  const nextEdgeId = (() => {
    const used = new Set<string>();
    for (const e of edges) {
      const id = typeof e?.id === "string" ? e.id : "";
      if (id) used.add(id);
    }
    return (base: string) => {
      let id = base;
      let i = 1;
      while (used.has(id)) {
        id = `${base}_${i}`;
        i++;
      }
      used.add(id);
      return id;
    };
  })();

  let workingEdges = edges;

  if (opts.normalizeEdgeEndpointsByLabel) {
    let normalized = 0;
    workingEdges = workingEdges.map((e) => {
      const source = typeof e?.source === "string" ? e.source : "";
      const target = typeof e?.target === "string" ? e.target : "";
      let nextSource = source;
      let nextTarget = target;

      if (source) {
        const sourceLower = source.toLowerCase();
        if (!idLowerToId.has(sourceLower)) {
          const norm = normalizeRef(source);
          if (norm && !ambiguousLabelNorms.has(norm)) {
            const resolved = labelNormToId.get(norm);
            if (resolved && resolved !== source) {
              nextSource = resolved;
              normalized++;
            }
          }
        }
      }

      if (target) {
        const targetLower = target.toLowerCase();
        if (!idLowerToId.has(targetLower)) {
          const norm = normalizeRef(target);
          if (norm && !ambiguousLabelNorms.has(norm)) {
            const resolved = labelNormToId.get(norm);
            if (resolved && resolved !== target) {
              nextTarget = resolved;
              normalized++;
            }
          }
        }
      }

      if (nextSource !== source || nextTarget !== target) {
        return { ...e, source: nextSource, target: nextTarget };
      }
      return e;
    });
    if (normalized > 0) fixes.push(`连线端点 label→id 纠正 ${normalized} 处`);
  }

  if (opts.removeInvalidEdges) {
    const before = workingEdges.length;
    workingEdges = workingEdges.filter((e) => {
      const source = typeof e?.source === "string" ? e.source : "";
      const target = typeof e?.target === "string" ? e.target : "";
      if (!source || !target) return false;
      return nodeIdSet.has(source) && nodeIdSet.has(target);
    });
    const removed = before - workingEdges.length;
    if (removed > 0) fixes.push(`删除无效连线 ${removed} 条`);
  }

  if (opts.ensureEdgeIds) {
    let added = 0;
    workingEdges = workingEdges.map((e, i) => {
      const id = typeof e?.id === "string" ? e.id : "";
      if (id) return e;
      const source = typeof e?.source === "string" ? e.source : "unknown";
      const target = typeof e?.target === "string" ? e.target : "unknown";
      const newId = nextEdgeId(`edge_${source}_${target}_${i}`);
      added++;
      return { ...e, id: newId };
    });
    if (added > 0) fixes.push(`补齐连线 id ${added} 条`);
  }

  if (opts.dedupeEdges) {
    const before = workingEdges.length;
    const seen = new Set<string>();
    const deduped: AnyEdge[] = [];
    for (const e of workingEdges) {
      const source = typeof e?.source === "string" ? e.source : "";
      const target = typeof e?.target === "string" ? e.target : "";
      const sh = e?.sourceHandle === undefined ? "" : String(e.sourceHandle);
      const key = `${source}::${target}::${sh}`;
      if (seen.has(key)) continue;
      seen.add(key);
      deduped.push(e);
    }
    workingEdges = deduped;
    const removed = before - workingEdges.length;
    if (removed > 0) fixes.push(`去重连线 ${removed} 条`);
  }

  {
    const appNodes = nodes
      .filter((n) => typeof n?.id === "string" && typeof n?.type === "string")
      .map((n) => ({ ...n, position: (n as any)?.position || { x: 0, y: 0 } })) as any;
    const ensured = ensureBranchHandles(appNodes as any, workingEdges as any);
    if (ensured.fixes.length > 0) {
      workingEdges = ensured.edges as any;
      fixes.push(`补齐 Branch 出边 sourceHandle ${ensured.fixes.length} 处`);
    }
  }

  if (opts.replaceVariableIdPrefixToLabel) {
    let idToLabelReplaced = 0;
    let inputTextReplaced = 0;
    let branchConditionReplaced = 0;
    let imageUrlReplaced = 0;

    const resolvePrefixType = (prefix: string): string => {
      const lower = prefix.toLowerCase();
      return idToType.get(prefix) || idToType.get(lower) || labelToType.get(prefix) || labelToType.get(lower) || "";
    };

    const rewriteBranchCondition = (condition: string): string => {
      return rewriteOutsideQuotes(condition, (segment) => {
        return segment.replace(/([a-zA-Z\u4e00-\u9fa5_][\w\u4e00-\u9fa5]*)\.(text|answer)\b/g, (match, prefix, field) => {
          const sourceType = resolvePrefixType(String(prefix));
          if (field === "text" && sourceType === "input") return `${prefix}.user_input`;
          if (field === "answer" && sourceType === "llm") return `${prefix}.response`;
          return match;
        });
      });
    };

    for (const node of nodes) {
      const nodeId = typeof node?.id === "string" ? node.id : "unknown";

      if (String(node?.type || "") === "branch") {
        const rawCond = typeof node?.data?.condition === "string" ? String(node.data.condition) : "";
        if (!rawCond.trim()) {
          node.data.condition = "true";
          fixes.push(`条件补齐：Node ${nodeId} 字段 data.condition 设为 true`);
        } else {
          const nextCond = rewriteBranchCondition(rawCond);
          if (nextCond !== rawCond) {
            node.data.condition = nextCond;
            branchConditionReplaced++;
            fixes.push(`条件修复：Node ${nodeId} 字段 data.condition 已修正字段引用`);
          }
        }
      }

      const fields = getStringFieldsToFix(node);
      for (const field of fields) {
        const vars = extractVariables(field.value);
        if (vars.length === 0) continue;
        let newValue = field.value;
        let modified = false;

        for (const varName of vars) {
          const prefix = parseVariablePrefix(varName);
          if (!prefix) continue;
          const prefixLower = prefix.toLowerCase();
          const idMatchedLabel = idToLabel.get(prefix) || idToLabel.get(prefixLower);
          const isIdReference = Boolean(idMatchedLabel);
          const shouldUseLabel = Boolean(isIdReference && idMatchedLabel && isAutoGeneratedId(prefix) && isSafeVariablePrefix(idMatchedLabel) && !ambiguousLabelNorms.has(normalizeRef(idMatchedLabel)));
          const targetPrefix = shouldUseLabel ? idMatchedLabel! : prefix;

          const suffix = varName.slice(prefix.length);
          const sourceType = isIdReference
            ? (idToType.get(prefix) || idToType.get(prefixLower) || "")
            : (labelToType.get(prefix) || labelToType.get(prefixLower) || "");

          let rebuilt = `${targetPrefix}${suffix}`;
          if (sourceType === "input" && suffix.startsWith(".text")) {
            rebuilt = `${targetPrefix}.user_input${suffix.slice(".text".length)}`;
            inputTextReplaced++;
          }
          if (sourceType === "imagegen" && suffix.startsWith(".image_url")) {
            rebuilt = `${targetPrefix}.imageUrl${suffix.slice(".image_url".length)}`;
            imageUrlReplaced++;
          }

          if (!shouldUseLabel && rebuilt === varName) continue;

          const escapedVarName = escapeRegExp(varName);
          newValue = newValue.replace(new RegExp(`\\{\\{\\s*${escapedVarName}\\s*\\}\\}`, "g"), `{{${rebuilt}}}`);
          modified = true;
          if (shouldUseLabel) idToLabelReplaced++;
        }

        if (modified) {
          setValueAtPath(node, field.fieldPath, newValue);
          fixes.push(`变量修复：Node ${nodeId} 字段 ${field.fieldPath} 已修正变量引用`);
        }
      }
    }
    if (idToLabelReplaced > 0) fixes.push(`变量 ID→Label 替换 ${idToLabelReplaced} 处`);
    if (inputTextReplaced > 0) fixes.push(`变量 Input.text → Input.user_input ${inputTextReplaced} 处`);
    if (branchConditionReplaced > 0) fixes.push(`条件字段修复（Input.text/LLM.answer）${branchConditionReplaced} 处`);
    if (imageUrlReplaced > 0) fixes.push(`变量 ImageGen.image_url → ImageGen.imageUrl ${imageUrlReplaced} 处`);
  }

  return { nodes, edges: workingEdges, fixes };
}
